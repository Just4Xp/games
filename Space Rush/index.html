<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Neon Space Dodger ‚Äî Hyper Mode</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#04050a;
    --glass: rgba(255,255,255,0.035);
    --glass-2: rgba(255,255,255,0.02);
    --accent-cyan: #7cf7ff;
    --accent-mag: #c07cff;
    --accent-amber: #ffb86b;
    --danger: #ff6b6b;
    --muted: rgba(255,255,255,0.28);
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{height:100%;margin:0;background:
    radial-gradient(800px 350px at 10% 10%, rgba(124,247,255,0.02), transparent 10%),
    linear-gradient(180deg,#02030a 0%, #040417 100%);
    color:#eaf6ff; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
  }

  .container{
    max-width:1100px;
    margin:28px auto;
    padding:18px;
    display:grid;
    grid-template-columns: 1fr 340px;
    gap:18px;
    align-items:start;
  }

  header{grid-column:1/-1; display:flex; justify-content:space-between; align-items:center; gap:12px}
  h1{margin:0;font-size:20px;color:var(--accent-cyan);letter-spacing:0.3px}
  .sub{color:var(--muted);font-size:13px}

  /* Game card */
  .game-area{
    background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
    border-radius:14px;
    padding:12px;
    box-shadow: 0 10px 40px rgba(2,6,23,0.6);
    position:relative;
    overflow:hidden;
  }

  /* Canvas */
  canvas{
    width:100%;
    height:640px;
    display:block;
    border-radius:10px;
    background: radial-gradient(circle at 20% 10%, rgba(124,247,255,0.02), transparent 8%),
                linear-gradient(180deg, rgba(10,10,20,0.3), rgba(0,0,0,0.35));
    touch-action:none;
    outline:0;
  }

  /* HUD & controls */
  .hud{
    display:flex;
    gap:10px;
    align-items:center;
    justify-content:space-between;
    margin-top:10px;
  }
  .controls{display:flex;gap:8px;align-items:center}
  .btn{
    padding:9px 14px;border-radius:10px;border:1px solid rgba(255,255,255,0.05);
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    color:var(--accent-cyan); font-weight:700; cursor:pointer; box-shadow: 0 6px 18px rgba(2,6,23,0.45)
  }
  .btn.ghost{background:transparent;color:var(--muted);border:1px dashed rgba(255,255,255,0.03)}

  /* Sidebar */
  .sidebar{display:flex;flex-direction:column;gap:12px}
  .card{background:linear-gradient(180deg,var(--glass),var(--glass-2)); padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.03); box-shadow:0 8px 22px rgba(2,6,23,0.45)}
  .stat-line{display:flex;justify-content:space-between;font-size:14px;color:var(--muted);align-items:center}
  .stat-line strong{color:var(--accent-cyan)}

  /* progress bar */
  .progress-wrap{background:rgba(255,255,255,0.03);border-radius:8px;overflow:hidden;height:12px}
  .progress{height:100%;width:0%;background:linear-gradient(90deg,var(--accent-cyan),var(--accent-mag));transition:width 300ms ease}

  /* messages */
  .msg{padding:10px;border-radius:10px;text-align:center;font-weight:700;color:var(--accent-cyan);background:linear-gradient(90deg,rgba(124,247,255,0.03),rgba(155,124,255,0.02))}

  /* small HUD in corner */
  .corner-hud{position:absolute;left:18px;top:18px;font-weight:700;font-size:13px;color:var(--muted);display:flex;gap:12px;align-items:center}
  .corner-hud .pill{background:rgba(0,0,0,0.2);padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,0.02)}

  /* animated neon title */
  .title-badge{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:999px;background:linear-gradient(90deg, rgba(124,247,255,0.04), rgba(155,124,255,0.02));border:1px solid rgba(255,255,255,0.02);font-weight:800;color:var(--accent-cyan)}

  /* responsive */
  @media (max-width:980px){
    .container{grid-template-columns:1fr; padding:12px}
    canvas{height:520px}
  }

  /* particle number pop */
  .pop {
    position: absolute;
    pointer-events: none;
    transform: translate(-50%,-50%);
    font-weight:800;
    text-shadow: 0 6px 18px rgba(2,6,23,0.6);
  }
</style>
</head>
<body>
<div class="container">
  <header>
    <div>
      <div class="title-badge">üöÄ Neon Space Dodger ‚Äî Hyper Mode</div>
      <div class="sub">Hardens quickly. Polished neon UI. Collect power-ups. Survive waves.</div>
    </div>
    <div class="sub">Controls: ‚Üê ‚Üí or A/D, Tap left/right, Space to Pause/Start, R to Restart</div>
  </header>

  <section class="game-area">
    <div class="corner-hud">
      <div class="pill" id="hiWrap">HI <strong id="hi">0</strong></div>
      <div class="pill" id="livesWrap">Lives <strong id="lives">3</strong></div>
      <div class="pill" id="levelWrap">Lvl <strong id="level">1</strong></div>
    </div>

    <canvas id="game" width="760" height="640" aria-label="Neon Space Dodger canvas"></canvas>

    <div class="hud">
      <div style="display:flex;gap:12px;align-items:center">
        <div class="controls">
          <button class="btn" id="startBtn">Start</button>
          <button class="btn ghost" id="pauseBtn">Pause</button>
          <button class="btn ghost" id="restartBtn">Restart</button>
        </div>
        <div style="min-width:220px">
          <div style="font-size:12px;color:var(--muted)">Score</div>
          <div style="display:flex;align-items:center;gap:12px">
            <div style="font-size:20px;font-weight:800;color:var(--accent-cyan)" id="score">0</div>
            <div style="font-size:12px;color:var(--muted)">√ó <span id="mult">1</span></div>
          </div>
        </div>
      </div>

      <div style="flex:1;display:flex;flex-direction:column;gap:8px">
        <div style="display:flex;justify-content:space-between;gap:12px">
          <div style="font-size:12px;color:var(--muted)">Level Progress</div>
          <div style="font-size:12px;color:var(--muted)">Wave <span id="wave">1</span></div>
        </div>
        <div class="progress-wrap"><div class="progress" id="progressBar"></div></div>
      </div>

      <div style="width:220px;display:flex;flex-direction:column;gap:8px;align-items:flex-end">
        <div class="msg" id="stateMsg">Ready</div>
        <div style="font-size:12px;color:var(--muted)">Collect crystals for combos & power-ups</div>
      </div>
    </div>
  </section>

  <aside class="sidebar">
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div style="font-size:13px;color:var(--muted)">Top Score</div>
          <div style="font-weight:800;font-size:20px;color:var(--accent-cyan)" id="hiPanel">0</div>
        </div>
        <div style="text-align:right">
          <div style="font-size:12px;color:var(--muted)">Lives</div>
          <div style="font-weight:800;font-size:20px;color:var(--accent-amber)" id="livesPanel">3</div>
        </div>
      </div>
      <hr style="margin:10px 0;border:none;border-top:1px solid rgba(255,255,255,0.03)">
      <div style="font-size:13px;color:var(--muted)">
        ‚Ä¢ Difficulty scales in waves. Each wave increases spawn rate + speed.<br>
        ‚Ä¢ New asteroid behaviors: splitting & homing at higher levels.<br>
        ‚Ä¢ Use power-ups: <strong>Shield</strong>, <strong>Slow</strong>, <strong>Blast</strong>, <strong>Extra Life</strong>.<br>
        ‚Ä¢ Restart to reset progress.
      </div>
    </div>

    <div class="card">
      <div style="font-weight:800;color:var(--accent-cyan)">Tips</div>
      <ul style="color:var(--muted);font-size:13px;line-height:1.5;margin:8px 0;padding-left:16px">
        <li>Hit power-ups to survive tough waves.</li>
        <li>Collect combos ‚Äî multiplier decays over time.</li>
        <li>Blast clears nearby threats ‚Äî rare but powerful.</li>
      </ul>
    </div>

    <div class="card">
      <div style="font-size:12px;color:var(--muted)">Version</div>
      <div style="font-weight:700;color:var(--muted)">Hyper Mode v2.0</div>
    </div>

  </aside>
</div>

<script>
/* Neon Space Dodger ‚Äî Hyper Mode
   Single-file game ready for CodePen.
   - stronger difficulty scaling, waves
   - polished HUD, ship with sprites (drawn), particles
   - several powerups, combos, pop numbers
*/

(() => {
  // Canvas + DPR
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false });

  // UI
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');
  const scoreEl = document.getElementById('score');
  const hiEl = document.getElementById('hi');
  const hiPanel = document.getElementById('hiPanel');
  const livesEl = document.getElementById('lives');
  const livesPanel = document.getElementById('livesPanel');
  const levelEl = document.getElementById('level');
  const stateMsg = document.getElementById('stateMsg');
  const progressBar = document.getElementById('progressBar');
  const waveEl = document.getElementById('wave');
  const multEl = document.getElementById('mult');

  let DPR = Math.max(1, window.devicePixelRatio || 1);
  function adaptCanvas(){
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * DPR);
    canvas.height = Math.floor(rect.height * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    W = rect.width;
    H = rect.height;
  }
  // initial size
  canvas.style.width = '100%';
  canvas.style.height = canvas.getAttribute('height') + 'px';
  let W = canvas.width / DPR, H = canvas.height / DPR;
  adaptCanvas();
  window.addEventListener('resize', () => { adaptCanvas(); });

  // game state
  let running = false, paused = false, lastTs = 0;
  let score = 0, high = Number(localStorage.getItem('nsd_hi_v2') || 0);
  let lives = 3, level = 1, wave = 1, waveProgress = 0;
  let combo = 1, comboTimer = 0;
  let waveTimer = 0;

  hiEl.textContent = high;
  hiPanel.textContent = high;
  livesEl.textContent = lives;
  livesPanel.textContent = lives;
  levelEl.textContent = level;

  // arrays
  const asteroids = [];
  const powerups = [];
  const particles = [];
  const pops = []; // floating score numbers

  // player ship (more detailed)
  const player = {
    x: W/2, y: H - 90, w: 48, h: 54,
    vx: 0, speed: 420, shield: 0, invuln: 0,
    angle: 0
  };

  // settings: base rates will be multiplied per wave/level
  const base = {
    spawnInterval: 0.9, // seconds
    asteroidSpeed: 90,
    asteroidCountPerWave: 12,
    waveLength: 18 // seconds per wave increase
  };

  // Input
  const keys = { left:false, right:false };
  window.addEventListener('keydown', (e) => {
    if(e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = true;
    if(e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = true;
    if(e.key === ' ') { e.preventDefault(); if(!running) startGame(); else togglePause(); }
    if(e.key === 'r' || e.key === 'R') restartGame();
  });
  window.addEventListener('keyup', (e) => {
    if(e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = false;
    if(e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = false;
  });

  // touch pointer
  let activePointer = null;
  canvas.addEventListener('pointerdown', (ev)=>{
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    activePointer = ev.pointerId;
    if(x < rect.width/2) { keys.left = true; keys.right = false; }
    else { keys.right = true; keys.left = false; }
    if(!running) startGame();
  });
  window.addEventListener('pointerup', (ev)=>{
    if(ev.pointerId === activePointer){ keys.left=false; keys.right=false; activePointer=null; }
  });
  window.addEventListener('pointercancel', ()=>{ keys.left=false; keys.right=false; activePointer=null; });

  // helpers
  function rand(min,max){ return Math.random()*(max-min)+min; }
  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
  function px(n){ return Math.round(n) + 'px'; }

  // asteroid factory with types: normal, big (splits), homing (later waves)
  function spawnAsteroid(type){
    const size = type === 'big' ? rand(44,72) : rand(18,40);
    const x = rand(size/2, W - size/2);
    const vy = base.asteroidSpeed + rand(10,60) + (level-1)*18 + wave*6;
    const vx = rand(-40,40);
    const rot = rand(0, Math.PI*2);
    const spin = rand(-2.5,2.5);
    const t = type || (Math.random() < 0.08 && level > 2 ? 'big' : 'normal');
    asteroids.push({ x, y: -size, r: size/2, vx, vy, rot, spin, type: t, hp: t === 'big' ? 2 : 1, color: `hsl(${rand(10,45)},85%,60%)` });
  }

  // powerup factory
  function spawnPowerup(kind, x) {
    const k = kind || (Math.random() < 0.5 ? 'shield' : (Math.random() < 0.5 ? 'slow' : 'blast'));
    const px = x || rand(30, W-30);
    const pu = { x: px, y: -18, r: 14, vy: rand(50,90), kind: k, color: k === 'shield' ? '#7cf7ff' : k === 'slow' ? '#9b7cff' : '#ffd76b' };
    powerups.push(pu);
  }

  // particles (explosions, engine exhaust)
  function spawnParticle(x,y, vx, vy, life, size, color){
    particles.push({ x, y, vx, vy, life, size, color, age: 0 });
  }

  // pops (score numbers)
  function spawnPop(x,y, txt, color){
    pops.push({ x, y, txt, color, age:0, life:1.1 });
  }

  // collision: circle vs rect
  function circleRect(cx, cy, cr, rx, ry, rw, rh){
    const nx = clamp(cx, rx, rx+rw);
    const ny = clamp(cy, ry, ry+rh);
    const dx = cx - nx, dy = cy - ny;
    return (dx*dx + dy*dy) <= cr*cr;
  }

  // draw ship (detailed neon ship)
  function drawShip(p){
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(p.angle);
    // thruster glow
    for(let i=0;i<3;i++){
      ctx.beginPath();
      ctx.ellipse(0 + rand(-1,1), 14 + i*2, 18 - i*6, 8 - i*2, 0, 0, Math.PI*2);
      ctx.fillStyle = `rgba(255,160,90,${0.04 - i*0.01})`;
      ctx.fill();
    }

    // hull
    ctx.beginPath();
    ctx.moveTo(0, -p.h/2);
    ctx.bezierCurveTo(p.w*0.5, -p.h*0.25, p.w*0.5, p.h*0.15, 0, p.h/2);
    ctx.bezierCurveTo(-p.w*0.5, p.h*0.15, -p.w*0.5, -p.h*0.25, 0, -p.h/2);
    ctx.closePath();
    ctx.fillStyle = '#05060a';
    ctx.fill();

    // neon outline
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(124,247,255,0.95)';
    ctx.stroke();

    // cockpit
    ctx.beginPath();
    ctx.ellipse(0, -6, 8, 9, 0, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(155,124,255,0.85)';
    ctx.lineWidth = 2;
    ctx.stroke();

    // side fins (neon)
    ctx.beginPath();
    ctx.moveTo(-p.w*0.45, 4);
    ctx.lineTo(-p.w*0.85, 14);
    ctx.lineTo(-p.w*0.28, 10);
    ctx.closePath();
    ctx.fillStyle = 'rgba(124,247,255,0.03)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(124,247,255,0.5)';
    ctx.lineWidth = 1.4;
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(p.w*0.45, 4);
    ctx.lineTo(p.w*0.85, 14);
    ctx.lineTo(p.w*0.28, 10);
    ctx.closePath();
    ctx.fillStyle = 'rgba(155,124,255,0.03)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(155,124,255,0.45)';
    ctx.lineWidth = 1.4;
    ctx.stroke();

    // thruster flame particles (render small circles behind)
    ctx.restore();
  }

  // draw asteroid
  function drawAst(a){
    ctx.save();
    ctx.translate(a.x, a.y);
    ctx.rotate(a.rot);
    const s = a.r;
    ctx.beginPath();
    // organic polygon
    const pts = 7;
    for(let i=0;i<pts;i++){
      const ang = (i/pts)*Math.PI*2;
      const rx = Math.cos(ang) * (s * (0.6 + 0.35*Math.sin(i*3 + a.rot) + (i%2?0.08:0)));
      const ry = Math.sin(ang) * (s * (0.6 + 0.35*Math.cos(i*2.5 + a.rot)));
      if(i===0) ctx.moveTo(rx,ry); else ctx.lineTo(rx,ry);
    }
    ctx.closePath();
    const g = ctx.createRadialGradient(-s*0.2,-s*0.1, s*0.05, 0,0,s);
    g.addColorStop(0, 'rgba(255,255,255,0.12)');
    g.addColorStop(1, a.color);
    ctx.fillStyle = g;
    ctx.fill();

    // border
    ctx.lineWidth = 1.2;
    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.stroke();
    ctx.restore();
  }

  // draw powerup
  function drawPU(pu){
    ctx.save();
    ctx.translate(pu.x, pu.y);
    // symbol circle
    ctx.beginPath();
    ctx.arc(0,0,pu.r,0,Math.PI*2);
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.stroke();

    // icon
    ctx.beginPath();
    if(pu.kind === 'shield'){
      ctx.arc(0,0,pu.r-6, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(124,247,255,0.95)';
      ctx.lineWidth = 2;
      ctx.stroke();
    } else if(pu.kind === 'slow'){
      ctx.moveTo(-6, -4); ctx.lineTo(6, -4);
      ctx.moveTo(-6, 4); ctx.lineTo(6, 4);
      ctx.strokeStyle = 'rgba(155,124,255,0.95)';
      ctx.lineWidth = 2.2;
      ctx.stroke();
    } else if(pu.kind === 'blast'){
      ctx.moveTo(-6,0); ctx.lineTo(0,-8); ctx.lineTo(6,0); ctx.lineTo(0,8); ctx.closePath();
      ctx.fillStyle = 'rgba(255,215,120,0.96)';
      ctx.fill();
    } else if(pu.kind === 'life'){
      ctx.beginPath();
      ctx.moveTo(-6,0); ctx.lineTo(0,-8); ctx.lineTo(6,0);
      ctx.moveTo(-6,0); ctx.lineTo(0,8); ctx.lineTo(6,0);
      ctx.strokeStyle = 'rgba(255,150,150,0.95)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    ctx.restore();
  }

  // explosion
  function explode(x,y, count, color){
    for(let i=0;i<count;i++){
      const ang = rand(0,Math.PI*2);
      const sp = rand(40,260);
      spawnParticle(x, y, Math.cos(ang)*sp, Math.sin(ang)*sp, rand(0.6,1.6), rand(2,5), color);
    }
  }

  // update loop
  let spawnTimer = 0;
  function update(dt){
    if(!running || paused) return;

    // combo decay
    if(comboTimer > 0) comboTimer = Math.max(0, comboTimer - dt);
    else combo = 1;

    // score increase passively
    score += dt * (6 + level*1.2) * combo;
    scoreEl.textContent = Math.floor(score);

    // wave progression
    waveTimer += dt;
    waveProgress = clamp(waveTimer / (base.waveLength - Math.min(8, level*0.6)), 0, 1);
    progressBar.style.width = Math.round(waveProgress * 100) + '%';
    if(waveProgress >= 1){
      // new wave
      wave += 1;
      waveEl.textContent = wave;
      waveTimer = 0;
      // small boost
      level += Math.floor(wave/3);
      levelEl.textContent = level;
      // spawn immediate burst
      for(let i=0;i<Math.min(6 + wave*1.5, 24); i++){
        spawnAsteroid(Math.random() < 0.12 ? 'big' : 'normal');
      }
      stateMsg.textContent = 'Wave ' + wave + '!';
      setTimeout(()=> { stateMsg.textContent = 'Playing'; }, 1400);
    }

    // spawn asteroids by spawnTimer; spawn rate decreases with level and wave
    spawnTimer -= dt;
    const spawnInterval = Math.max(0.18, base.spawnInterval - (level*0.04) - Math.min(wave*0.02, 0.5));
    if(spawnTimer <= 0){
      // spawn 1-2 asteroids; sometimes big; occasionally homing if high wave
      const count = Math.random() < 0.2 ? 2 : 1;
      for(let i=0;i<count;i++){
        const p = Math.random();
        if(p < Math.min(0.12 + wave*0.02, 0.35) && level > 3){
          // big or homing
          if(Math.random() < 0.5) spawnAsteroid('big'); else {
            // homing: type homing, behaves specially
            const a = { x: rand(20, W-20), y: -rand(20,60), r: rand(18,34), vx: rand(-30,30), vy: base.asteroidSpeed + rand(40,120) + level*12, rot: rand(0,Math.PI*2),
                        spin: rand(-3,3), type: 'homing', hp:1, color: `hsl(${rand(10,45)},85%,60%)` };
            asteroids.push(a);
          }
        } else {
          spawnAsteroid(Math.random() < 0.06 ? 'big' : 'normal');
        }
      }
      // occasional powerup spawn
      if(Math.random() < 0.13 + Math.min(wave*0.01, 0.12)) spawnPowerup();
      spawnTimer = spawnInterval;
    }

    // update asteroids
    for(let i=asteroids.length-1;i>=0;i--){
      const a = asteroids[i];
      a.rot += a.spin * dt;
      // homing behavior nudges towards player slightly
      if(a.type === 'homing'){
        const dx = player.x - a.x, dy = player.y - a.y;
        const ang = Math.atan2(dy, dx);
        // steer slowly
        a.vx += Math.cos(ang) * 40 * dt;
        a.vy += Math.sin(ang) * 10 * dt;
        const speedCap = base.asteroidSpeed + level*20 + wave*10 + 120;
        const sp = Math.hypot(a.vx, a.vy);
        if(sp > speedCap){
          const f = speedCap / sp;
          a.vx *= f; a.vy *= f;
        }
      }

      a.x += a.vx * dt;
      a.y += a.vy * dt;

      // off-screen cleanup
      if(a.y - a.r > H + 80 || a.x < -200 || a.x > W + 200){
        asteroids.splice(i,1);
        continue;
      }

      // collision with player
      if(player.invuln <= 0 && circleRect(a.x, a.y, a.r, player.x - player.w/2, player.y - player.h/2, player.w, player.h)){
        if(player.shield > 0){
          // destroy asteroid, remove shield
          player.shield = 0;
          explode(a.x, a.y, 18, 'rgba(180,240,255,0.9)');
          spawnPop(a.x, a.y, '+' + 18, '#7cf7ff');
          asteroids.splice(i,1);
          score += 12 * combo;
          combo += 0.2; comboTimer = 2.2;
        } else {
          // hit: lose life
          explode(player.x, player.y, 22, 'rgba(255,80,80,0.95)');
          spawnPop(player.x, player.y - 20, '-1', '#ff6b6b');
          lives -= 1;
          livesEl.textContent = lives;
          livesPanel.textContent = lives;
          player.invuln = 1.6;
          player.shield = 0;
          // camera shake simulated via flash
          flashTimer = 0.14;
          if(lives <= 0){ endGame(); return; }
        }
      }
    }

    // update powerups
    for(let i=powerups.length-1;i>=0;i--){
      const p = powerups[i];
      p.y += p.vy * dt;
      if(p.y - p.r > H + 30){ powerups.splice(i,1); continue; }
      if(circleRect(p.x, p.y, p.r, player.x - player.w/2, player.y - player.h/2, player.w, player.h)){
        // apply powerup
        if(p.kind === 'shield'){ player.shield = 6.2; spawnPop(player.x, player.y - 18, 'Shield', '#7cf7ff'); }
        else if(p.kind === 'slow'){ // slow time
          // slow asteroids velocities
          asteroids.forEach(a => { a.vx *= 0.45; a.vy *= 0.55; });
          setTimeout(()=> { asteroids.forEach(a => { a.vx *= 2.2; a.vy *= 1.82; }); }, 2200);
          spawnPop(player.x, player.y - 18, 'Slow', '#9b7cff');
        }
        else if(p.kind === 'blast'){ // clear small asteroids
          explode(p.x, p.y, 14, 'rgba(255,210,120,0.95)');
          // remove nearby asteroids
          for(let j=asteroids.length-1;j>=0;j--){
            const a = asteroids[j];
            const d2 = (a.x-p.x)*(a.x-p.x) + (a.y-p.y)*(a.y-p.y);
            if(d2 < 110*110){
              explode(a.x,a.y,10,'rgba(255,200,140,0.9)');
              spawnPop(a.x,a.y,'+'+10,'#ffd76b');
              asteroids.splice(j,1);
              score += 8 * combo;
            }
          }
          spawnPop(player.x, player.y - 18, 'Blast', '#ffd76b');
        } else if(p.kind === 'life'){
          lives += 1; livesEl.textContent = lives; livesPanel.textContent = lives;
          spawnPop(player.x, player.y - 18, '+1 Life', '#ffd1d1');
        }
        score += 20 * combo;
        combo += 0.35; comboTimer = 2.4;
        powerups.splice(i,1);
      }
    }

    // update particles
    for(let i=particles.length-1;i>=0;i--){
      const pr = particles[i];
      pr.age += dt;
      if(pr.age >= pr.life){ particles.splice(i,1); continue; }
      pr.x += pr.vx * dt;
      pr.y += pr.vy * dt;
      // slight drag
      pr.vx *= 0.995; pr.vy *= 0.995;
    }

    // update pops
    for(let i=pops.length-1;i>=0;i--){
      const pp = pops[i];
      pp.age += dt;
      if(pp.age >= pp.life){ pops.splice(i,1); continue; }
      pp.y -= 28 * dt;
    }

    // update player
    let dir = 0;
    if(keys.left) dir -= 1;
    if(keys.right) dir += 1;
    player.vx = dir * player.speed;
    player.x += player.vx * dt;
    player.x = clamp(player.x, player.w/2 + 8, W - player.w/2 - 8);
    // angle tilt
    player.angle = clamp(dir * 0.45 + (player.angle * 0.85), -0.6, 0.6);
    if(player.invuln > 0) player.invuln = Math.max(0, player.invuln - dt);
    if(player.shield > 0) player.shield = Math.max(0, player.shield - dt);

    // small chance to spawn powerup on asteroid destruction in update of splitting handled elsewhere

    // asteroid splitting: if big asteroid reaches HP==0 we spawn two smaller
    for(let i=asteroids.length-1;i>=0;i--){
      const a = asteroids[i];
      // if hp <=0 triggered earlier; skip (we remove in collision)
    }

    // clamp combo display
    multEl.textContent = combo.toFixed(1).replace('.0','');
  }

  // draw
  let flashTimer = 0;
  function draw(){
    // background gradient + starfield
    ctx.fillStyle = '#04050a';
    ctx.fillRect(0,0,W,H);

    // moving stars
    const t = Date.now() / 1000;
    ctx.save();
    for(let i=0;i<60;i++){
      const sx = ((i*37 + Math.sin(t*0.6 + i) * 40) % W + W) % W;
      const sy = ((i*83 + Math.cos(t*0.9 + i) * 60) % H + H) % H;
      const s = (i%6 === 0) ? 2.2 : (i%10 === 0 ? 1.3 : 0.9);
      ctx.fillStyle = 'rgba(180,220,255,0.02)';
      ctx.fillRect(sx, sy, s, s);
    }
    ctx.restore();

    // draw asteroids sorted by y for depth
    asteroids.sort((a,b)=> a.y - b.y);
    for(const a of asteroids) drawAst(a);

    // draw powerups
    for(const p of powerups) drawPU(p);

    // draw particles (behind ship as well)
    for(const pr of particles){
      ctx.globalAlpha = 1 - (pr.age/pr.life);
      ctx.beginPath();
      ctx.arc(pr.x, pr.y, pr.size, 0, Math.PI*2);
      ctx.fillStyle = pr.color;
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // draw player thruster flames as particles
    // spawn engine particles when moving
    const exhaustCount = (Math.abs(player.vx) > 10) ? 2 : 1;
    for(let i=0;i<exhaustCount;i++){
      const exx = player.x + rand(-6,6);
      const exy = player.y + player.h*0.45 + rand(-2,4);
      spawnParticle(exx, exy, rand(-22,22) + player.vx* -0.02, rand(90,160), 0.45, rand(1.5,3.6), 'rgba(255,165,90,0.85)');
    }

    // draw ship last
    // draw shield ring if present
    if(player.shield > 0){
      ctx.beginPath();
      ctx.ellipse(player.x, player.y - 2, player.w*1.1, player.h*0.95, 0, 0, Math.PI*2);
      ctx.fillStyle = `rgba(124,247,255,${0.08 + 0.02*Math.sin(t*6)})`;
      ctx.fill();
    }
    drawShip(player);

    // draw pops (floating numbers)
    for(const pp of pops){
      ctx.font = '800 14px Inter';
      ctx.fillStyle = pp.color;
      ctx.fillText(pp.txt, pp.x - 6, pp.y);
    }

    // HUD overlay on canvas
    ctx.save();
    ctx.font = '700 13px Inter';
    ctx.fillStyle = 'rgba(124,247,255,0.95)';
    ctx.fillText('Score: ' + Math.floor(score), 12, 22);
    ctx.fillStyle = 'rgba(155,124,255,0.85)';
    ctx.fillText('Lvl: ' + level + '  Wave: ' + wave, 12, 42);
    ctx.restore();

    // screen flash
    if(flashTimer > 0){
      ctx.fillStyle = 'rgba(255,80,80,' + (0.06 * (flashTimer / 0.14)) + ')';
      ctx.fillRect(0,0,W,H);
      flashTimer = Math.max(0, flashTimer - 0.01);
    }
  }

  // main animation loop
  let animStarted = false;
  function loop(ts){
    if(!lastTs) lastTs = ts;
    const dt = Math.min(0.06, (ts - lastTs)/1000);
    lastTs = ts;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // start/pause/restart handlers
  function startGame(){
    running = true; paused = false; lastTs = 0;
    // reset core state if starting fresh (only if not mid-game)
    if(!animStarted){
      animStarted = true;
      requestAnimationFrame(loop);
    }
    // if starting from ready state, reset
    if(!startBtn.disabled){
      resetCoreState();
      startBtn.disabled = true;
    }
    stateMsg.textContent = 'Playing';
  }
  function togglePause(){
    if(!running) return;
    paused = !paused;
    stateMsg.textContent = paused ? 'Paused' : 'Playing';
    pauseBtn.classList.toggle('ghost', !paused);
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
  }
  function restartGame(){
    startBtn.disabled = false;
    running = false;
    paused = false;
    stateMsg.textContent = 'Ready';
    pauseBtn.textContent = 'Pause';
    pauseBtn.classList.add('ghost');
    resetCoreState();
  }

  function resetCoreState(){
    score = 0; lives = 3; level = 1; wave = 1; waveTimer = 0; waveProgress = 0;
    combo = 1; comboTimer = 0;
    asteroids.length = 0; powerups.length = 0; particles.length = 0; pops.length = 0;
    player.x = W/2; player.y = H - 90; player.shield = 0; player.invuln = 0;
    spawnTimer = 0.6;
    scoreEl.textContent = 0; hiEl.textContent = high; hiPanel.textContent = high;
    livesEl.textContent = lives; livesPanel.textContent = lives;
    levelEl.textContent = level; waveEl.textContent = wave;
    progressBar.style.width = '0%';
    // pre-populate some asteroids for immediate interest
    for(let i=0;i<6;i++) spawnAsteroid(Math.random() < 0.07 ? 'big' : 'normal');
  }

  function endGame(){
    running = false;
    paused = false;
    stateMsg.textContent = 'Game Over';
    startBtn.disabled = false;
    pauseBtn.classList.add('ghost');
    // update high score
    const s = Math.floor(score);
    if(s > high){
      high = s;
      localStorage.setItem('nsd_hi_v2', high);
      hiEl.textContent = high;
      hiPanel.textContent = high;
      stateMsg.textContent = 'NEW HIGH SCORE!';
    }
  }

  // on asteroid destruction: give score and maybe split
  function destroyAsteroid(i){
    const a = asteroids[i];
    explode(a.x, a.y, Math.round(a.r/2 + 6), 'rgba(255,180,120,0.92)');
    spawnPop(a.x, a.y, '+' + Math.round(8 * combo), '#ffd76b');
    score += Math.round(8 * combo);
    combo += 0.15; comboTimer = 2.0;
    // chance to spawn powerup
    if(Math.random() < 0.12) spawnPowerup(null, a.x);
    // split if big
    if(a.type === 'big' && a.hp > 0){
      // create 2 smaller asteroids
      const pieces = 2 + Math.floor(Math.random()*2);
      for(let p=0;p<pieces;p++){
        const nr = clamp(a.r * (0.5 + Math.random()*0.25), 10, 28);
        const nvx = rand(-90,90);
        const nvy = rand(80,180) + level*6;
        asteroids.push({ x: a.x + rand(-8,8), y: a.y + rand(-8,8), r: nr, vx: nvx, vy: nvy, rot: rand(0,Math.PI*2), spin: rand(-3,3), type: 'normal', hp:1, color: a.color });
      }
    }
    asteroids.splice(i,1);
  }

  // click handling to shoot blast (optional) - we won't add shooting, but allow tapping a power action maybe
  // small flash support
  function flash(){
    flashTimer = 0.14;
  }

  // HUD clickable power: when user double-click canvas, trigger blast if available? To keep simple, we skip this.

  // mouse collision for splitting asteroids by clicking (debug)
  canvas.addEventListener('dblclick', (ev) => {
    if(!running) return;
    const rect = canvas.getBoundingClientRect();
    const mx = ev.clientX - rect.left, my = ev.clientY - rect.top;
    // destroy nearest asteroid within radius
    let best = -1, bd = 999999;
    for(let i=0;i<asteroids.length;i++){
      const a = asteroids[i];
      const d2 = (a.x-mx)*(a.x-mx) + (a.y-my)*(a.y-my);
      if(d2 < bd && d2 < 60*60){ bd = d2; best = i; }
    }
    if(best >= 0) destroyAsteroid(best);
  });

  // main interactions (buttons)
  startBtn.addEventListener('click', startGame);
  pauseBtn.addEventListener('click', togglePause);
  restartBtn.addEventListener('click', restartGame);

  // initial idle
  resetCoreState();

  // small interval to randomly spawn idle asteroids if not running
  setInterval(()=>{
    if(!running){
      if(Math.random() < 0.45) spawnAsteroid();
      if(Math.random() < 0.06) spawnPowerup();
    }
  }, 700);

  // simulate asteroid hits when player overlaps with tiny asteroids via pointer - handled in update

  // animation kickoff
  if(!animStarted){
    animStarted = true;
    requestAnimationFrame(loop);
  }

  // expose for debugging
  window._nsd_v2 = {
    spawnAsteroid, spawnPowerup, getState: ()=>({score,high,lives,level,wave,asteroidsLength:asteroids.length,powerupsLength:powerups.length})
  };
  // Back to hub
backHubButton.addEventListener('click', () => {
  location.href = "../index.html"; // Adjust if your hub is in a different folder
});
})();
</script>
</body>
</html>
